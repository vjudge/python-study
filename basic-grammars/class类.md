# class类

类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础。
* 类：一群有着相似性的事物的集合，这里对应 Python 的 class
* 对象：集合中的一个事物，这里对应由 class 生成的某一个 object
* 属性：对象的某个静态特征
* 函数：对象的某个动态能力


### 语法
在 Python 中，类具有多态、封装、继承。不过，Python 中没有重载，类的定义细节也具有明显差异。定义类的一般形式如下：
```
class ClassName:
    <statement-1>
    ...
    <statement-N>
```
类的本质是一种数据结构，一个类通常包含数据成员和函数成员。数据成员用于刻画类所描述的一类事物的属性，函数成员用于完成具体的任务。
```
class ClassName:
    # 定义类的数据成员
    varName = ''

    # 定义一个函数： 
    def funcName(self):
        ...
```


### self 参数
类中的函数必须有一个额外的参数 self，并且 self 参数必须放在第一个参数的位置。
self 的内容是一个地址，它代表当前实例，也就是当前对象的地址。
self 参数并不是 Python 的保留关键字，而是为了便于理解，按照惯例命名而来。事实上，换做其它名字也可以（须遵循规则：必须是类函数的第一个参数）。


### 实例化
Python类，在进行实例化创建对象的时候，会自动调用__init()__函数。该函数用于创建对象，并赋予所创建对象初始状态。
```
p1 = Person()
p1 = Person('张三', 18)
```

### 构造函数
Python 没有重载特性，只能定义一个构造函数，且函数名为 __init__，若不定义构造函数，则默认为 __init__(self)。


### 继承
通过继承，子类可以重用父类中的函数和数据成员。  
继承，通常将实施继承行为的类称为子类（Child Class）或者派生类（Derived Class），被继承的类称为父类（Parent Class）或者基类（Base Class)。  
每个类都有构造函数，继承类在生成对象的时候，是不会自动调用父类的构造函数的，因此你必须在 init() 函数中显式调用父类的构造函数。它们的执行顺序是 子类的构造函数 -> 父类的构造函数。
```
class childClassName(parentClassName):
    <statement-1>
    ...
    <statement-N>
```


### 多继承
一个子类继承多个父类。
多继承中，子类继承了不同父类中的属性和函数，这些属性和函数可能存在同名的情况，在子类使用这些同名的函数或属性时，在没有指定的情况下，Python 将根据一定顺序进行搜索：首先搜索子类，如果未找到则根据多继承定义的顺序，从左至右在父类中查找。
```
class childClassName(parentClassName1，parentClassName2，…):
    <statement-1>
    ...
    <statement-N>
```


### 函数重写
从父类继承来的函数并不能完全满足需求，需要在子类中对其进行修改，这就是重写的概念：在子类中重写父类中的函数，当子类对象调用该名称的函数时，会调用子类中重写的函数，父类中的同名函数将被覆盖。


### 私有属性与私有方法
在某些场景下，我们并不希望对外暴露类的内部细节，为了限制外部访问，我们可以将对应的属性和函数设置为私有。将类的属性和函数设置为私有的一般形式为以下两种：
* 定义私有属性：__attribute，属性名前面加两个下划线，即声明该属性为私有，不能在类的外部直接访问，在类内部访问时用 self.__attribute。
* 定义私有函数：__function，函数名前面加两个下划线，即声明该函数为私有，不能在类的外部直接访问，在类内部访问时用 self.__ function。
对于私有属性和私有函数，如果需要在类外访问，可以通过公有函数实现。


### 成员函数
能够访问或者修改对象的属性。  
成员函数不需要任何装饰器声明，第一个参数 self 代表当前对象的引用，可以通过此函数，来实现想要的查询 / 修改类的属性等功能。


### classmethod: 类函数
能够访问或者修改对象的属性。  
类函数需要装饰器 @classmethod 来声明。类函数的第一个参数一般为 cls，表示必须传一个类进来。类函数最常用的功能是实现不同的 init 构造函数。


### staticmethod: 静态函数
与类没有什么关联，最明显的特征便是，静态函数的第一个参数没有任何特殊性。  
静态函数可以用来做一些简单独立的任务，既方便测试，也能优化代码结构。静态函数可以通过在函数前一行加上 @staticmethod 来表示。


### delattr(object, name)
删除对象的属性。


### getattr(object, name[, default])
获取对象的属性。


### hasattr(object, name)
对象是否有某属性。


### isinstance(object, class1)
判断object是否是类class1是实例。


### issubclass(class2, class1)
判断class2是否为class1的子类。


### property(fget=None, fset=None, fdel=None, doc=None)
返回property属性。


### super([type[, object-or-type]])
返回一个代理对象，它会将方法调用委托给 type 的父类或兄弟类。


### 抽象函数
抽象类是一种特殊的类，生下来就是作为父类存在的，一旦对象化就会报错。抽象函数定义在抽象类之中，子类必须重写该函数才能使用。相应的抽象函数，则是使用装饰器 @abstractmethod 来表示。










